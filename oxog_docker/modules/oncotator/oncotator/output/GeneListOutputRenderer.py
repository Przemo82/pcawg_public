from collections import OrderedDict
import csv
import logging
from oncotator.output.OutputRenderer import OutputRenderer
from oncotator.utils.ConfigUtils import ConfigUtils
from oncotator.utils.MutUtils import MutUtils


class GeneListOutputRenderer(OutputRenderer):
    """
     Render segments to a list of genes with the segment annotations attached to each gene.

     For example:
     input annotated segments:

     chr    start   end genes   annotation1 annotation2
     1  100 10000000    FAKE1,FAKE2 3   foo
     3  120 12000000    DUMMY1  5   bar

     output gene list generated by this class:

     gene   annotation1 annotation2
     FAKE1  3   foo
     FAKE2  3   foo
     DUMMY1 5   bar

    More realistic example output:
        gene segment_contig segment_start  segment_end  segment_mean    segment_call

    A gene can be listed multiple times if broken up by two separate segments.

    IMPORTANT: This class only supports the rendering of segments.

    This class uses more RAM than most of the other OutputRenderers and RAM usage will scale up with the number of genes.


    """
    def __init__(self, filename, config_file="", other_options=None):
        self._filename = filename
        self._config_file = config_file


    def renderMutations(self, segments, metadata=None, comments=None):
        """Render segments into a gene list as described in the docs for this class.

        :param segments: iterable of MutationData
        :param metadata:
        :param comments:
        """

        config_parser = ConfigUtils.createConfigParser(self._config_file)

        logging.getLogger(__name__).info("Building alternative keys dictionary...")
        self._alternativeDictionary = ConfigUtils.buildAlternateKeyDictionaryFromConfig(config_parser)

        if metadata is None:
            metadata = OrderedDict()

        if comments is None:
            comments = []

        fp = file(self._filename, 'w')
        for c in comments:
            fp.write("## " + c + "\n")

        # TODO: Define constant for "genes", and other annotations
        headers = config_parser.options("alternatives")
        gene_to_segment_dict = dict()
        annotations = None
        i = 0
        for i, seg in enumerate(segments):
            if annotations is None:
                annotations = seg.keys()
                field_mapping = MutUtils.createFieldsMapping(headers, annotations, self._alternativeDictionary, isRenderInternalFields=True, prepend="")

            gene_list = seg['genes'].split(",")
            for g in gene_list:
                if g == seg["start_gene"]:
                    gene_to_segment_dict[g + " " + seg["start_exon"]] = seg
                elif g == seg["end_gene"]:
                    gene_to_segment_dict[g + " " + seg["end_exon"]] = seg
                else:
                    gene_to_segment_dict[g] = seg


        if i == 0:
            logging.getLogger(__name__).info("No segments given.  There will be no genes in the list.")

        writer = csv.DictWriter(fp, headers, delimiter="\t", lineterminator="\n", extrasaction="ignore")
        writer.writeheader()

        logging.getLogger(__name__).info("Rendering gene list...")
        all_genes_seen = sorted(gene_to_segment_dict.keys())
        num_genes = len(all_genes_seen)
        for i,gene in enumerate(all_genes_seen):
            # This next line may be slow...
            line_dict = dict()
            seg = gene_to_segment_dict[gene]
            for h in headers:
                annotation_field = field_mapping.get(h, h)
                line_dict[h] = seg.get(annotation_field, "")
            line_dict["gene"] = gene
            writer.writerow(line_dict)
            if i % 1000 == 0:
                logging.getLogger(__name__).info("Rendered %d/%d genes ..." % ((i+1),num_genes))

        fp.close()


